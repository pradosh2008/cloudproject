#!/usr/bin/bash

. ${HOME}/lib/set_env.sh
. ${HOME}/lib/common.sh

#creating the landing table
bq load --replace=true --source_format=CSV --skip_leading_rows=1 --quote='' --field_delimiter="|" \
        --schema=${schema_path}/edl_landing/lbca_vmci173_full_email_address.json \
        edl_landing.lbca_vmci173_full_email_address \
        "gs://${default_bucket}/plus/crm/vmci173_full_email_address*.txt.gz"
rc_check $? "Load edl_landing"

#loading the temporary table in staging
bq query --max_rows 1 --allow_large_results --destination_table edl_stage.lbca_vmci173_full_email_address_new --use_legacy_sql=false <<!
#SELECT
# stgn.ID_EMAIL
#,stgn.ID_EMAIL_DOMAIN
#,stgn.NU_BB_SOFT
#,stgn.NU_BB_HARD
#,stgn.CD_EMAIL_STYLE
#,stgn.DA_TMCI173_CREATED
#,stgn.DA_TMCI173_UPDATED
#,stgn.IN_CUST_SOURCE_FIRST
#,stgn.IN_CUST_SOURCE_2ND_FIRST
#,stgn.IN_CUST_SOURCE_LAST
#,stgn.IN_CUST_SOURCE_2ND_LAST
#,stgn.CD_EMAIL_INVALID
#,stgn.DA_FRST_HARD_BB
#,stgn.DA_LAST_HARD_BB
#,stgn.DA_FIRST_SOFT_BB
#,stgn.DA_LAST_SOFT_BB
#,stgn.EXTRACT_TS
#from
#(SELECT lbca.*
#,ROW_NUMBER() OVER (partition by lbca.ID_EMAIL
#order by lbca.EXTRACT_TS desc) as row_num
#from
#(
SELECT
 CAST(TRIM(c.ID_EMAIL) AS INT64) as ID_EMAIL
,CAST(TRIM(c.ID_EMAIL_DOMAIN) AS INT64) as ID_EMAIL_DOMAIN
,CAST(TRIM(c.NU_BB_SOFT) AS INT64) as NU_BB_SOFT
,CAST(TRIM(c.NU_BB_HARD) AS INT64) as NU_BB_HARD
,TRIM(c.CD_EMAIL_STYLE) AS CD_EMAIL_STYLE
,case when TRIM(c.DA_TMCI173_CREATED)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_TMCI173_CREATED)) end as DA_TMCI173_CREATED
,case when TRIM(c.DA_TMCI173_UPDATED)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_TMCI173_UPDATED)) end as DA_TMCI173_UPDATED
,TRIM(c.IN_CUST_SOURCE_FIRST) AS IN_CUST_SOURCE_FIRST
,TRIM(c.IN_CUST_SOURCE_2ND_FIRST) AS IN_CUST_SOURCE_2ND_FIRST
,TRIM(c.IN_CUST_SOURCE_LAST) AS IN_CUST_SOURCE_LAST
,TRIM(c.IN_CUST_SOURCE_2ND_LAST) AS IN_CUST_SOURCE_2ND_LAST
,TRIM(c.CD_EMAIL_INVALID) AS CD_EMAIL_INVALID
,case when TRIM(c.DA_FRST_HARD_BB)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_FRST_HARD_BB)) end as DA_FRST_HARD_BB
,case when TRIM(c.DA_LAST_HARD_BB)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_LAST_HARD_BB)) end as DA_LAST_HARD_BB
,case when TRIM(c.DA_FIRST_SOFT_BB)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_FIRST_SOFT_BB)) end as DA_FIRST_SOFT_BB
,case when TRIM(c.DA_LAST_SOFT_BB)='' then null
 else PARSE_DATE("%Y-%m-%d",TRIM(c.DA_LAST_SOFT_BB)) end as DA_LAST_SOFT_BB
,case when TRIM(c.EXTRACT_TS)='' then null
 else PARSE_TIMESTAMP("%Y-%m-%d %H:%M:%S",c.EXTRACT_TS,"America/New_York") end as EXTRACT_TS
from edl_landing.lbca_vmci173_full_email_address c
#) lbca
#) stgn
#where stgn.row_num = 1
!
rc_check $? "Load incremental data from edl_landing into temp table"

#Merge/UPSert old records into new stage table
bq query  --max_rows 1 --allow_large_results --append_table --destination_table edl_stage.lbca_vmci173_full_email_address_new --use_legacy_sql=false <<!
select c.*
from edl_stage.plus_vmci173_full_email_address c
left join edl_stage.lbca_vmci173_full_email_address_new w
    on w.ID_EMAIL=c.ID_EMAIL
    and EXTRACT(date from w.EXTRACT_TS)=EXTRACT(date from c.EXTRACT_TS)
    where w.ID_EMAIL is null
!
rc_check $? "Merge or UPSert old records into new stage table"

#cleansing and archival
bq cp --force edl_stage.plus_vmci173_full_email_address edl_archive.plus_vmci173_full_email_address
rc_check $? "archive copy"
bq cp --force edl_stage.lbca_vmci173_full_email_address_new edl_stage.plus_vmci173_full_email_address
rc_check $? "replace the temp table as the stage table"
bq rm --force edl_stage.lbca_vmci173_full_email_address_new
rc_check $? "drop the temp table"

# This function is only stubbed in â€“ it runs but currently does not archive your files
archive_bucket_files "gs://${default_bucket}/plus/crm/vmci173_full_email_address*.txt.gz"

